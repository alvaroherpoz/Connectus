/**
 * @fileoverview Plantilla para generar el archivo principal (`icuasw_mmesp_project.cpp`) del proyecto EDROOM.
 * Genera las inclusiones, instancias y configuración de los componentes.
 */
import type { Node, NodeData } from '../../components/types';

/**
 * Genera el contenido del archivo principal del proyecto EDROOM.
 */
export class icuasw_mmesp_project_template {
    /**
     * Genera el contenido del archivo `icuasw_mmesp_project.cpp` para un nodo lógico específico.
     * @param {Node<NodeData>[]} nodes - Todos los nodos del diagrama.
     * @param {string} localNodeName - El nombre del nodo lógico para el que se genera el código.
     * @returns {string} El contenido del archivo .cpp.
     */
    public static generateMainFileContent(nodes: Node<NodeData>[], localNodeName: string): string {

        const includes = nodes.map(c => {
            const name = c.data.componentClass.replace(/\s/g, '').toLowerCase();
            const prefix = this.getIncludePrefix(c, localNodeName);
            return `#include <public/${prefix}${name}_iface_v1.h>`;
        }).join('\n');

        // Generar las instancias de los componentes
        const initComponents = nodes.map(c => {
            const id = c.data.componentId;
            const maxMessages = c.data.maxMessages;
            const priority = c.data.priority;
            const stackSize = c.data.stackSize;
            const componentClass = this.getComponentClass(c, localNodeName);
            const finalInstanceName = this.getInstanceName(c, localNodeName);
            const memoryName = this.getInstanceName(c, localNodeName);

            return `\t${componentClass}  ${finalInstanceName}(${id}, ${maxMessages}, ${priority}, ${stackSize}, systemDeployment.Get${memoryName}Memory());`;
        }).join('\n');
        
        // Generar la lista de componentes para la configuración
        const configComponents = nodes.map(c => {
            const instanceName = this.getInstanceName(c, localNodeName);
            return `&${instanceName}`;
        }).join(', ');

        return `//##############################################################################
//###############    This file has been generated by Connectus    ###############
//##############################################################################

#include <public/edroom_glue.h>


//******************************************************************************
// include deployment edroom components
${includes}

#ifdef CONFIG_EDROOMBP_DEPLOYMENT_NEED_TASK

    CEDROOMSystemDeployment systemDeployment;

#endif


rtems_task Init (uint32_t arg){

    //uint32_t aux;

#ifndef CONFIG_EDROOMBP_DEPLOYMENT_NEED_TASK

    CEDROOMSystemDeployment systemDeployment;

#endif

    //aux=sizeof(systemDeployment) + sizeof(ICUASW)+   sizeof(CCEPDManager);
    //aux+= sizeof(CCTM_ChannelCtrl) +sizeof(RCCHK_FDIRMng) +sizeof(RCCBKGTCExec);

${initComponents}

    //if(aux< 32*1024){
    systemDeployment.Config(${configComponents});

    systemDeployment.Start();
    //}
    //;

}
    
`;
    }

    /**
     * Obtiene el nombre de la instancia de un componente.
     * @param {Node<NodeData>} node - El nodo del componente.
     * @param {string} localNodeName - El nombre del nodo lógico actual.
     * @returns {string} El nombre de la instancia (p. ej., `rcomponente` o `componente`).
     */
    private static getInstanceName(node: Node<NodeData>, localNodeName: string): string {
        const isRemote = node.data.node !== localNodeName;
        const componentNameBase = node.data.name.replace(/\s/g, '');
        
        if (isRemote) {
            return `r${componentNameBase}_${node.id}`;
        }
        return `${componentNameBase}_${node.id}`;
    }

    /**
     * Obtiene el nombre de la clase C++ para un componente.
     * @param {Node<NodeData>} node - El nodo del componente.
     * @param {string} localNodeName - El nombre del nodo lógico actual.
     * @returns {string} El nombre de la clase (p. ej., `RComponente`, `CCComponente`).
     */
    private static getComponentClass(node: Node<NodeData>, localNodeName: string): string {
        const isRemote = node.data.node !== localNodeName;
        const componentType = node.data.componentClass.replace(/\s/g, '');

        if (node.data.isTop && isRemote) {
            return `R${componentType}`;
        } else if (node.data.isTop && !isRemote) {
            return componentType;
        } else if (!node.data.isTop && isRemote) {
            return `R${componentType}`;
        } else {
            return `${componentType}`;
        }
    }

    /**
     * Obtiene el prefijo para la directiva `#include` de un componente.
     * @param {Node<NodeData>} node - El nodo del componente.
     * @param {string} localNodeName - El nombre del nodo lógico actual.
     * @returns {string} El prefijo del include (p. ej., `r`, `cc`).
     */
    private static getIncludePrefix(node: Node<NodeData>, localNodeName: string): string {
        const isRemote = node.data.node !== localNodeName;
        
        if (node.data.isTop && isRemote) {
            return 'r';
        } else if (node.data.isTop && !isRemote) {
            return '';
        } else if (!node.data.isTop && isRemote) {
            return 'r';
        } else {
            return '';
        }
    }
}